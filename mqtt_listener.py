# mqtt_listener.py
# Purpose:
#   Minimal MQTT "listener" that subscribes to a device's topic and prints every
#   message to stdout. Useful for quick debugging/validation of your MKR↔Nicla pipeline.
#
# How to run:
#   1) pip install paho-mqtt
#   2) python mqtt_listener.py
#
# Notes:
#   - This listens to test.mosquitto.org (public test broker). Data is public.
#   - Topic uses a wildcard ("#") to capture all subtopics under devices/{DEVICE_ID}/.
#   - QoS=1 is used for reasonable delivery assurance without changing payloads.

from paho.mqtt import client as mqtt

# ---- Connection/configuration parameters ----
DEVICE_ID = "mkr-kitchen-01"            # Must match the DEVICE_ID your firmware publishes under
BROKER = "test.mosquitto.org"           # Public test broker (no auth)
PORT   = 1883                           # Standard unencrypted MQTT port
TOPIC  = f"devices/{DEVICE_ID}/#"       # Subscribe to all subtopics for this device

def on_connect(client, userdata, flags, rc):
    """
    MQTT callback: fired after the TCP+MQTT handshake completes.
    rc == 0 means success; nonzero indicates a connection error.
    """
    print("Connected with result code", rc)
    # Subscribe once connected. QoS=1 = at-least-once delivery.
    client.subscribe(TOPIC, qos=1)
    print("Subscribed:", TOPIC)

def on_message(client, userdata, msg):
    """
    MQTT callback: fired for every incoming message on any subscribed topic.
    Decodes payload to UTF-8 (ignoring errors) and prints topic + payload.
    """
    try:
        payload = msg.payload.decode("utf-8", "ignore")  # robust to non-UTF8 bytes
    except Exception:
        payload = str(msg.payload)                       # final fallback (repr-like)
    print(msg.topic, payload)

# ---- Create client, attach callbacks, connect, and start the network loop ----
client = mqtt.Client()                    # No client_id → auto-generated by library
client.on_connect = on_connect
client.on_message = on_message

# keepalive=60 → the broker expects a ping every ≤60s via loop_forever()
client.connect(BROKER, PORT, keepalive=60)

print("Listening on:", BROKER, "topic:", TOPIC)

# Blocking loop that handles socket I/O, pings, reconnections, and calls callbacks.
client.loop_forever()
